# 1, 2장 운영체제 개요 및 컴퓨터시스템의 구조

날짜: 2022년 10월 26일
주차: 1
태그: 리버

영상: [운영체제](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

## 강의 목표

운영체제는 컴퓨터 하드웨어 바로 위에 설치되는 소프트웨어 계층으로서 모든 컴퓨터 시스템의 필수적인 부분이다. 본 강좌에서는 이와 같은 운영체제의 개념과 역할, 운영체제를 구성하는 각 요소 및 그 알고리즘의 핵심적인 부분에 대해 기초부터 학습한다.

## **[1 운영체제 개요](https://core.ewha.ac.kr/publicview/C0101020140307151724641842?vmode=f)**

## **운영 체제란?**

- 운영체제: 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층

### *협의의 운영체제(커널)*

- 운영체제의 핵심 부분으로 메모리에 상주하는 부분

*메모리: 주기억장치, RAM, 기억할 내용이 전기 신호로 저장됨, 하드디스크를 이용하는 것보다 속도 빠름

*커널: 컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램으로, 시스템의 모든 것을 완전히 통제한다. 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지 서비스를 제공

### *광의의 운영체제*

- 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념

![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled.png)

## **운영 체체의 목적**

- ⭐️ 컴퓨터 시스템의 자원을 효율적으로 관리
    - 프로세서, 기억장치, 입출력 장치 등의 효율적 관리
        - 사용자간의 형평성 있는 자원 분배
        - 주어진 자원으로 최대한의 성능을 내도록
    - 사용자 및 운영체제 자신의 보호
    - 프로세스, 파일, 메시지 등을 관리

- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
    - 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공
    - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행

## **운영 체제의 분류**

### *1) 동시 작업 가능 여부*

- 단일 작업(single tasking)
    - 한 번에 하나의 작업만 처리
        
        예) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음
        
- 다중 작업(multi tasking)
    - 동시에 두 개 이상의 작업 처리
        
        예) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음
        

### *2) 사용자의 수*

- 단일 사용자(single user)
    
    예) MS-DOS, MS Windows(예전)
    
- 다중 사용자(multi user)
    - 계정을 여러 개 만들고, 원격으로 여러 명이 접속할 수 있음
    - 예) UNIX, NT server

*UNIX: 유닉스(Unix)는 벨 연구소에서 개발한 운영 체제로, 대부분의 현대적 컴퓨터 운영 체제의 원형이 되었다. 윈도우를 제외한 macOS, iOS 등의 대부분의 운영 체제가 유닉스를 그 뿌리로 하고 있다.

*NT server: MS Windows의 모든 운영체제

### *3) 처리 방식*

- 일괄 처리(batch processing)
    - 작업 요청의 일정량 모아서 한꺼번에 처리
    - 작업이 완전 종료될 때까지 기다려야 함
        
        예) 초기 Punch Card 처리 시스템
        

*punch card: 정해진 위치에 구멍이 뚫려 있는지 아닌지로 2진법 데이터를 기록한 카드. 초기 컴퓨터의 기억장치로도 사용.

- 시분할(time sharing)
    - 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용
    - 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐
        
        예) UNIX
        
    - Interactive한 방식(내가 입력이나 동작을 하면 바로 적용된 것을 볼 수 있음)
- 실시간(Realtime OS)
    - 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야하는 실시간 시스템을 위한 OS
        
        예) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어
        
    - 실시간 시스템의 개념 확장
        - Hard real-time system: 아주 정확해야 함(예) 로켓, 반도체
        - soft real-time system(데드라인은 있지만, 어긋나도 큰 문제는 없는 경우. 예를 들어 영화 재생 등)

## 몇 가지 용어

![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled%201.png)

## **운영 체제의 예**

### *DOS(Disk Operating System)*

- MS사에서 1981년 IBM-PC를 위해 개발
- 단일 사용자용 운영체제, 메모리 관리 능력의 한계(주 기억 장치: 640KB)

### *MS Windows*

- MS사의 다중 작업용 GUI 기반 운영 체제
- Plug and Play 네트워크 환경 강화
- DOS용 응용 프로그램과 호환성 제공
- 불안정성(유닉스, 리눅스는 오픈소스여서 많은 사람들이 수정 보완을 거침. 그러나 Windows는 내부적으로만 개발. 그러나 최근에는 많이 나아진 상태)

- 풍부한 지원 소프트웨어

*Plug and Play: 컴퓨터에 하드웨어를 연결하면 별도의 사용자 조작이나 프로그램 설치 없이 바로 사용할 수 있는 것.

### *Handheld device를 위한 OS*

- PalmOS, Pocket PC(WinCE), Tiny OS

*PalmOS: 스마트폰 운영 체제

*Win CE: 네비게이션 등 소형 PC에 탑재되는 Windows 운영체제

*Tiny OS: 센서 네트워크를 위한 완전 무료 운영 체제이며, 현재 세계에서 가장 큰 센서 네트워크 커뮤니티를 형성하고 있으며, 빠른 기능 구현 및 업그레이드가 커뮤니티를 통해 진행되고 있는 소프트웨어 플랫폼이다.

### *유닉스(UNIX)*

- 코드의 대부분을 C언어로 작성(기계어와 유사한 C언어의 특징)
- 높은 이식성
- 최소한의 커널 구조
- 복잡한 시스템에 맞게 확장 용이
- 소스 코드 공개
- 프로그램 개발에 용이
- 다양한 버전
    - System V, FreeBSD, SunOS, Solaris
    - Linux(여러 환경에서 커널 사용 가능, 기능적으로 유닉스와 유사할 뿐 유닉스에서 파생된 것은 아니다.)

## **운영 체제의 구조**

![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled%202.png)

## **[2 시스템 구조 및 프로그램의 실행 Part-1](https://core.ewha.ac.kr/publicview/C0101020140311132925816476?vmode=f)**

## **컴퓨터 시스템 구조**

![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled%203.png)

- Disk: 저장 장치이기도 하지만, output device이기도 하다.

![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled%204.png)

- register: 메모리보다 더 빠르면서 정보를 저장할 수 있는 공간
- mode bit: CPU에서 실행되는 것이 OS인지 사용자의 프로그램인지 구분
- Interrupt line: CPU는 항상 Memory의 instruction을 순서대로 실행하는 것인데, 키보드에서 입력이 들어왔다든지, Disk에서 정보가 왔다든지 이러한 외부 정보를 이것이 알려준다.
- local buffer: CPU는 원칙적으로 Memory에만 접근하는데, I/O device들의 작업은 local buffer에서 데이터를 받아서 한다. buffer에 쌓이게 되면 CPU가 그 내용을 읽어서 자신의 Memory에 쌓을 수 있다. 그러다보니 CPU가 너무 interrupt를 많이 당하기도 한다.그래서 DMA controller를 둔다.
- DMA controller: 직접 Memory에 접근할 수 있는 controller. CPU에 직접 interrupt가 걸려서 CPU가 직접 작업을 읽어와 자신의 Memory에 할당하는 것은 overhead가 크기 때문에, CPU는 자신의 일을 하고 DMA controller가 local buffer에서 Memory로 복사해주는 일을 한다. 그 작업이 모두 끝나면 CPU에게 interrupt를 한 번만 걸어 보고를 해주어 CPU를 효율적으로 쓸 수 있게 해준다. 만약 CPU와 controller 둘 다 Memory에 접근하려고 할 때 충돌이 일어날 수 있는데, 이런 상황은 memory controller가 관리한다.

### **Mode bit**

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원
    
    `1` 사용자 모드: 사용자 프로그램 수행
    
    `0` 모니터 모드*: OS 코드 수행
    
    - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 '특권명령'으로 규정
    - Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꿈
    - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅
        - `모니터 모드` = 커널 모드, 시스템 모드
    
    ![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled%205.png)
    

### **Timer**

- timer: 특정 프로그램이 CPU를 독점(무한 루프 등)하는 것을 막는다. 처음에는 OS가 CPU를 가지고 있다가 다른 프로그램이 실행되면 timer에게 시간을 세팅하고 프로그램에게 CPU를 그 시간만큼 넘겨준다.(1초보다도 훨씬 작은 시간이다.)

### **Device Controller**

- I/O device controller
    - 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU
    - 제어 정보를 위해 control register, status register를 가짐
    - local buffer를 가짐(일종의 data register)
- I/O는 실제 device와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림
    - device driver(장치구동기): OS 코드 중 각 장치별 처리루틴 -> software
    - device controller(장치제어기): 각 장치를 통제하는 일종의 작은 CPU -> hardware

### *입출력(I/O)의 수행*

- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 I/O를 하는가?
    - 시스템콜(system call): 사용자 프로그램과 커널을 연결해주는 API를 만드는 도구
        - 사용자 프로그램은 운영체제에게 I/O 요청
    - trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
    - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
    - 올바른 I/O 요청인지 확인 후 I/O 수행
    - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

### **입출력과 인터럽트 (Input-Output and Interrupt)**

> 현대의 운영체제는 인터럽트에 의해 구동됨
> 
- 인터럽트
    - 인터럽트 당한 시점의 레지스터와 program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다
- Interrupt(넓은 의미)
    - Interrupt(하드웨어 인터럽트): 하드웨어가 발생시킨 인터럽트
    - Trap(소프트웨어 인터럽트)
        - Exception: 프로그램이 오류를 범한 경우
        - System call: 프로그램이 커널 함수를 호출하는 경우. 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것.
- 인터럽트 관련 용어
    - 인터럽트 벡터
        - 인터럽트 발생 시 실행해야 하는 함수들의 일종의 테이블. 해당 인터럽트의 처리 루틴 주소를 가지고 있음
    - 인터럽트 처리 루틴(=Interrupt Service Routine, 인터럽트 핸들러)
        - 해당 인터럽트를 처리하는 커널 함수

## **[2 시스템 구조 및 프로그램의 실행 Part-2](https://core.ewha.ac.kr/publicview/C0101020140314151238067290?vmode=f)**

### **동기식 입출력과 비동기식 입출력**

- CPU는 빠른 일꾼이다: 컴퓨터가 켜져 있는 동안 메모리의 instruction을 읽어서 실행한다.
- 다음 instruction을 하기 전에 interrupt가 있는지 확인한다. 있다면 지금 하던 작업을 잠시 멈추고 CPU 제제권이 OS에게 넘어간다. interrupt 별로 실행해야 할 일들은 커널 함수로 저장되어 있다. (interrupt vector와 처리 루틴 )

![image-20220624195006273.png](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/image-20220624195006273.png)

![image-20220624195315944.png](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/image-20220624195315944.png)

### **DMA (Direct Memory Access)**

![image-20220624200225238.png](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/image-20220624200225238.png)

### **서로 다른 입출력 명령어**

![image-20220624201932864.png](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/image-20220624201932864.png)

- 좌측: 일반적인 I/O. I/O용 주소가 따로 존재
- 우측: I/O 장치도 메모리 주소에 연장 주소를 붙인 방식

| I/O 방식 | I/O Mapped I/O (Port Mapped I/O) | Memory Mapped I/O |
| --- | --- | --- |
| 특징 | 메모리와 I/O 장치에 접근 방식이 다름 | I/O 장치도 전부 메모리 주소로 취급하여 접근 |
| 장점 | 메모리와 I/O 장치에 각각 최적화된 방식으로 접근 
명령어도 다르기 때문에 어셈블리 코드를 보기 좋음
메모리의 주소 영역을 전부 사용할 수 있음 | 포트 입출력을 따로 구현하지 않아 내부 로직이 간단함 → 임베디드 구현 시 장점 |

[메모리 맵 입출력 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%A7%B5_%EC%9E%85%EC%B6%9C%EB%A0%A5#:~:text=%EC%A0%95%EB%B3%B4%EB%A7%8C%EC%9D%84%20%EA%B0%80%EC%A7%80%EA%B2%8C%20%EB%90%9C%EB%8B%A4.-,%EB%91%90%20%EC%9E%85%EC%B6%9C%EB%A0%A5%20%EB%B0%A9%EC%8B%9D%EC%9D%98%20%EC%83%81%EB%8C%80%EC%A0%81%EC%9D%B8%20%EC%9E%A5%EC%A0%90%EB%93%A4,-%5B%ED%8E%B8%EC%A7%91%5D)

### **저장장치 계층 구조**

![image-20220624202137829.png](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/image-20220624202137829.png)

- Primary: CPU가 직접 접근하여 바로 실행 가능. 바이트 단위로 접근 가능.
- Secondary: 하드 디스크 등 바이트 단위가 아닌 섹터 단위로 접근 가능
- 위로 갈 수록 비싸고 속도가 빠르다.

### **프로그램의 실행 (메모리 load)**

![image-20220624202614936.png](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/image-20220624202614936.png)

- 가상메모리를 거쳐 실제 메모리에 올라가 프로세스가 된다.
    - code: CPU에서 실행할 코드
    - data: 전역변수 등 프로그램에서 사용하는 자료 구조들
    - stack: 함수를 호출할 때 데이터를 쌓고 가져가는 곳

-> 이러한 주소공간들을 메모리에 올려서 사용함. 쓰지 않는 것은 디스크의 Swap area에 놓음. 프로그램이 종료되면 사라짐. 메모리 낭비를 막기 위해.

### **커널 주소 공간의 내용**

![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled%206.png)

- PCB: 프로세스 제어 블록(Process Control Block)의 약자로, CPU에 의해 실행 중인 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영 체제 커널의 자료 구조

### **사용자 프로그램이 사용하는 함수**

![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled%207.png)

![Untitled](1,%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2095029389562e43c9aa04537faa8d0022/Untitled%208.png)

- 프로그램의 생명 주기는 이렇게 반복된다.