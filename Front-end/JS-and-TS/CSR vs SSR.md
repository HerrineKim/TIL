# Packet이란

정보 기술에서 패킷 방식의 컴퓨터 네트워크가 전달하는 데이터의 형식화된 블록이다. 패킷은 제어 정보와 사용자 데이터로 이루어지며, 이는 페이로드라고도 한다. 패킷을 지원하지 않는 컴퓨터 통신 연결은 단순히 바이트, 문자열, 비트를 독립적으로 연속하여 데이터를 전송한다. 데이터가 패킷으로 형식이 바뀔 때, 네트워크는 장문 메시지를 더 효과적이고 신뢰성 있게 보낼 수 있다.



# 👩‍💻 SSR vs CSR 비교 설명, Next.js가 탄생하게 된 이유

(https://www.sarah-note.com/%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9/posting2/)

# SSR(Server Side Rendering)

![p1 ssr](README.assets/p1_ssr.jpg)



👆 위의 그림은 전통적인 방식인 SSR을 표현한 것이다.
클라이언트(브라우저)가 데이터를 요청하면 그림의 순서대로 `브라우저`=>`프론트 서버`=>`백엔드 서버`=>`데이터베이스` 를 거쳐 데이터베이스에서 데이터를 가져온 후 다시 브라우저에 데이터가 그려지는 형식이다.
이 방식은 **서버에서 데이터까지 모두 포함하여 페이지를 구성**한 후 브라우저에 전달하는데

클라이언트가 페이지를 이동한다든가, 클릭으로 인한 다른 요청이 생길때마다 이 과정을 반복하기 때문에 화면에서 바뀌지 않아도 되는 부분도 계속해서 다시 렌더링되는 단점이 있다. 이는 곧 서버 부하 등의 문제를 일으킬 수 있다.

> 서버에서 페이지를 구성하여 반환한다.
> (단점) 불필요한 부분까지 다시 렌더링하게 된다.



# CSR(Client Side Rendering)

![p1 csr](README.assets/p1_csr.jpg)

CSR은 react, vue 등의 SPA(Single Page Application)에서 쓰이는 기법으로, 서버에서 화면을 구성했던 SSR 방식과 달리 클라이언트에서 화면을 구성한다.

SPA의 경우 첫 화면에 들어가게 되면, 그림의 1번처럼 **데이터를 제외한** 화면을 그리는 코드들이 프론트 서버에서 다운받아 진다. (데이터를 제외한 코드들은 js파일에 한번에 번들되어 오기때문에 번들된 이 파일을 처음에 다운받는데 시간이 꽤 걸릴 수 있다. 이것이 CSR방식의 단점이다=> 초기 진입속도가 SSR에 비해 느림/ code splitting이라는 기능으로 어느정도 해결 가능)

화면을 그리는 코드는 다운받았지만 아직 데이터를 다운 받은 상태가 아니다. CSR의 경우 클라이언트의 요청이 발생하면 필요한 데이터만 백엔드 서버에 요청하여 데이터만 받아온다.

CSR은 초기 진입 속도가 느린 반면, 그 후론 필요한 데이터만 갱신하면 되기때문에 SSR방식에 비해 서버 부하가 덜하다는 장점이 있다.

하지만 초기에 html에 데이터가 없다보니 검색 봇이 해당페이지를 빈페이지로 착각하여 SEO(Search Engine Optimization) 검색엔진 최적화에 취약할 수 있는 단점이 존재한다.
(똑똑한 구글 검색 봇은 예외라고 한다…)



> (장점) 필요한 데이터만 백엔드에서 가져와 서버 부하가 덜하다.
> (단점) 번들된 js파일 다운로드로 초기 진입속도가 느릴 수 있다.
> (단점) SSR에 비해 SEO에 약한편이다.(구글 제외)



# 두 문제를 해결한 Next.js

SSR의 단점 : 불필요한 부분까지 렌더링이 된다.
CSR의 단점 : 초기 진입 속도가 느리다. SEO에 취약하다.

위 두가지 단점을 해결하면서 두 방식의 장점을 살리고자..

Next.js라는 프레임워크가 생겼다. Next.js를 사용하여 첫페이지는 백엔드 서버에서 렌더링하여 빈 html이 아닌 데이터가 채워진 html을 받아 검색최적화 문제를 해결하고

그 다음 페이지부턴 CSR방식을 적용하여 필요한 데이터 부분만 갱신해 서버의 부하도 줄이게 한 것이다.

Next.js의 기능은 리액트로도 구현이 가능하지만 러닝커브가 있는 편이다.



> Next.js는 리액트의 SSR을 쉽게 구현해주는 프레임워크다.
> 실무에선 SSR과 Code Splitting 기능을 꼭 넣어 작업하자.
