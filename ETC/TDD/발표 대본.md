[TOC]

# Intro

1

안녕하세요 오늘 프론트엔드에서의 TDD, 테스트 주도 개발에 대해 발표할 김혜린이라고 합니다. 테스트 주도 개발은 말 그대로 테스트 코드를 작성하고 그것을 기반으로 개발하는 방법을 말하는 데요. 사실 TDD를 주제로 재성님이 6월에 발표를 해주셨는데, 개인적으로 공부를 해보고 싶었던 주제이기도 하고, 프론트엔드를 맡고 있다 보니 이번에는 React 테스팅 도구와 Jest라는 테스팅 도구를 사용한 예제와 함께 TDD에 관해 살펴보는 시간을 가지려고 합니다.

# 테스트 코드, 작성하시나요?

2

먼저 테스트 코드 다들 작성해 보시는지 여쭤보고 싶은데요.

## Not really...^^

3

사실 저부터도 잘 작성하게 되지는 않습니다.  나름의 이유가 있습니다. 일단 일반적으로 일정이 빠듯합니다. 기획, 디자인, 개발, 배포까지 하려면 항상 일정이 빠듯하다 보니 늘 뒷전이었고요. 힘든 것에 비해 효과는 잘 알지 못했기에 쓰게 되지 않았습니다. 또 프로젝트 끝나고 나중에 하면 되는데, 그 나중은 한번도 오지 않았었죠 ㅎㅎ

예시를 한 번 보면 제가 예전에 개발했던 독서 기록 앱에서 OCR 기능의 코드인데요. 여러 단계의 기능이 한 메서드 안에 들어가 있거나, UI도 한 컴포넌트에서 모두 해결하려 했었습니다. 오류 지점을 찾지 못해서 주말 이틀을 날리고 나서야 분리와 테스팅을 나중에 나마 해보기로 결심했습니다. 그런데 아직도 이렇게 GitHub에 있죠.

4


이런 현실에도 불구하고, TDD는 한 번 알아볼 만한 가치가 있다고 생각했습니다.

# TDD란?

5 6

TDD, 괜히 영어 약자라서 그렇지 직관적인 의미를 가지고 있습니다. 어떤 기능을 작성할 때 테스트 코드를 작성하고, 그것을 통과하는 코드를 작성하는 방식으로 개발한다고 우선 이해하시면 됩니다. 그래서 "테스트 '기반' 개발" 입니다.

## TDD를 집대성한 켄트 백(1961~)

7

TDD를 집대성했다고 할 수 있는 분은 켄트 벡이라는 개발자인데요. 책에서 많이 보셨을 XP 프로그래밍 기법을 창시했으며, TDD의 교과서라고 볼 수 있는 책을 썼습니다.

## TDD의 목표

8

TDD의 목표는 Clean code that works, 작동하는 깨끗한 코드입니다. 이것이 프로그래밍의 주된 목표이고, 그것을 TDD가 돕는다고 생각하는 건데요. TDD를 하며 먼저 “작동하는 코드” 부분을 해결하고 그 다음 “깔끔한 코드” 부분을 리팩토링으로 해결하는 겁니다.

테스트 주도 개발 책에서는 '두려움이 지루함으로 변할 때까지 테스트를 만들어라' 라고 하는데요, 결국 지루할 만큼 신뢰도 있고 깨끗한 코드를 만들기 전까지 테스트하라고 말합니다.

## TDD에 대한 오해

9

그렇다면 TDD가 오류 없는 완벽한 프로그램을 만드는 데 방점을 둔 것으로 오해할 수 있는데요. 그런 것이 아니라고 합니다.

## 사실은 이렇습니다

10

TDD가 도와주고자 하는 건 테스트를 먼저 작성해야 한다는 원칙을 통해 개발자가 코드를 작성하기 전에 전체적인 설계나 요구 사항에 대해 꼼꼼하게 생각할 수 있도록 하여 좋은 소프트웨어 디자인을 유도하고,

또 기능의 스펙, 요건을 코드 상에 남김으로써 협업 혹은 이 코드를 미래에 다른 사람이 볼 때 명확히 이해할 수 있고, 또 협업을 할 때라면 DB 등 공용 로직을 건드리지 않고 개발하여 예기치 못한 문제를 방지할 수 있습니다.

## TDD cycle

12

앞서 잠시 들으신 것과 같이, TDD의 Cycle은 이렇습니다. 테스트가 필요한 것들의 목록을 정립하고, 그 동작들의 용례들을 적습니다. 그리고 우선 실패하는 단위 테스트를 추가한다. 그리고 테스트를 통과하도록 프로덕션 코드를 구현한다. 기능을 훼손하지 않는 선에서 리팩토링하여 중복을 제거한다. 위 과정을 반복한다.

13

cycle만 보면 간단해 보이지만, test가 가능한 코드를 먼저 설계하는 것이 중요합니다. 이따 보시겠지만 테스트를 작성한다는 것이 곧 코드가 머리 속에 있다는 것이기 때문입니다. testable한 코드를 잘 만드는 일은 '관심사의 분리' 를 통해 이루어 집니다. 관심사의 분리란 컴퓨터 프로그램을 개개의 구별된 부분으로 분리시키는 디자인 원칙인데요.

14

이를 SRP라고 하는 단일 책임 원칙과도 연결할 수 있습니다. 하나의 모듈은 하나의 책임 만을 가져야 한다는 원칙입니다. 이렇게 TDD는 좋은 설계 아래서 잘 이루어 질 수 있고, 역으로 TDD가 좋은 설계를 하기 위한 좋은 자극이 되어 주기도 한다고 합니다.

# React 예제로 보는 TDD

15

그럼 이제 React Todo App을 TDD로 구현한 예제를 한 번 보겠습니다.

재작년 FEConf에서 공유된 내용을 따라서 구현을 해봤는데요. 

16 

실습에서는 Jest를 사용할 건데, Facebook에서 만들었으며 Weekly download가 무려 만 팔 천 대를 보이고 있네요. Jest가 인기 있는 이유는 Test Runner, Test의 값을 비교해 주는 Test Matcher 등 테스팅에 필요한 다양한 기능을 한 번에 제공하기 때문입니다.

17

그리고 React Testing Library의 도움도 함께 받을 겁니다. 코드를 보면서 이해하실 수 있을 것 같아요.

18

## List 출력

### Item

먼저 Jest의 기본 예시를 살펴보기 위해 투두리스트를 출력해 주는 기능을 TDD로 구현한 것을 보겠습니다.

`Item.test.jsx`

먼저 test 함수를 선언하고 옆에는 함수 설명을 적습니다. 할 일 하나인 Item 컴포넌트를 테스트 한다는 것이니 Item이라고 적습니다. 그리고 예시로 넣어서 테스트해 볼 데이터를 선언합니다. 실제 입력을 받거나 DB에서 올 것으로 예상되는 데이터와 같은 것으로 해야겠죠.

그리고 밑은 jest에서 클릭 함수를 만들어 주었다고 이해하면 되고, render 함수를 이용해 실제 렌더링 될 컴포넌트를 import한 다음 그려 줍니다. 필요한 데이터와 함수도 넘겨 주고요. 그리고 거기서 앞서 보셨던 container와 getByText를 통해 DOM의 요소들을 가져옵니다.

expect는 예상되는 결과 값인데요. 위 데이터에서 저는 title과 완료 버튼이 item 컴포넌트에 나올 것을 계획하고 있기 때문에 container에 이 두 글자가 표시될 것을 검증합니다.

마지막으로 클릭을 하는 것처럼 꾸미고, 클릭을 하면 함수가 1회 호출되는지를 검증합니다.

그리고 나서 이렇게 jest를 실행하는 명령어를 실행하면, 지금 제가 다른 코드는 전부 작성을 해놓아서 조금 맞지는 않지만, 이렇게 item이 없기 때문에 상위 컴포넌트에서도 연쇄적으로 오류가 발생한 것입니다. 이제 테스트를 잘 통과하도록 작성합니다.

18

보신 것처럼 Jest는 이런 메서드들을 쓰는데, describe는 작은 단위의 테스트들을 그룹화 하며, it은 테스트 함수이고, expect는 테스트의 결과를 검증해서 많은 matcher 함수, 그러니까 결괏값을 검증하는 함수들과 같이 씁니다.

### List

19

이제 item들로 이루어진 List를 볼 텐데요.

20

그 전에 BDD라는 것에 대해서 잠깐 설명을 드리겠습니다. BDD는 행동 주도 개발이라고 해서, 어떤 맥락이 있는 행위를 테스트 단위로 생각하고, 기존에서 context 함수가 추가되어 행위마다 분기를 해 줍니다. 설명을 비개발자가 봐도 이해할 수 있을 정도로 작성하여 협업에 도움이 된다고 합니다.

`List.test.jsx`

리스트 컴포넌트의 테스트 코드를 볼까요.

우선 테스트가 여러 개니 describe로 묶어 주고, render 함수도 여러 번 쓰일 테니 묶어 줍니다.

그리고 두 가지 행동에 따라 테스트 하는데요, 남은 할 일이 리스트에 존재하는 경우와 존재하지 않는 경우입니다.

그래서 context로 어떤 행동인지 구분을 지어주고, 각각 할 일이 잘 출력 되는지, 혹은 할 일이 없다면 기본으로 설정해 놓은 문구가 출력 되는지 확인을 할 겁니다.

실패를 했다고 가정하고,

`List.jsx`

실제 리스트 컴포넌트로 와서는 경우에 따라 할 일이 없어요 혹은 item들을 렌더링 해 줘야 할 것입니다.

## Redux와 TDD

21

이제 마지막으로 상태 관리와 TDD 이야기인데요.

Redux의 공식 문서를 보면 이렇게 Presentational한 컴포넌트와 Container 컴포넌트를 분리하여 상태에 대한 관심을 컨테이너에서만 관리하라고 말하고 있습니다. TDD가 지향하는 바와도 일치합니다.

### reducer

그래서 상태 관리 함수인 reducer도 이렇게 어떤 결과를 낼 것인지 테스트가 가능합니다. API 함수의 용례를 정확히 명시하니 협업이 수월할 것 같다는 생각이 들었습니다.



간단한 코드였지만 이 코드가 복잡하다고 생각해 봅시다. OCR을 촬영하고, 인코딩하고, Google에 보내고, 다시 받아서 JSON을 파싱하여 유저에게 보여 주는 수많은 단계가 의존적으로 이루어졌으나 구분하려는 노력을 하지 않아서 머리 속 진흙처럼 있었습니다. 제가 만약 TDD를 적용하려고 노력했다면 먼저 요구 사항을 잘 쪼개어 정리했을 것이고, 어디서 오류가 발생하는지도 단 번에 알게 되었을 겁니다.

# No Silver Bullet

24 25

이전 TDD 발표에서도 나누셨던 것처럼 TDD는 만능이 아닙니다. No silver bullet이라는 말처럼 좋은 개발, 설계를 보장해 주는 방법론은 없다고 하죠.

26

실제로 테스트를 잘 통과하면서도 좋은 소프트웨어 원칙에 어긋나는 코드들도 많으며,  단기적으로는 적용하기 어렵다는 현실은 가장 큰 장벽이 됩니다.

# 그럼에도 불구하고 TDD를 도입해 볼 이유는

27

그럼에도 불구하고 TDD를 도입해 볼 이유가 있다면

28

일단 프로젝트 규모가 점점 커진다고 하면, 미래의 큰 위험을 현재의 작은 에러로 가져올 수 있는 좋은 방법이 됩니다

그리고 가장 중요한 것은 기능 스펙을 명료하게 하고, 좋은 설계를 유도합니다.

 또, TDD가 장기적으로는 비용과 시간을 절감한다는 여러 통계들도 있습니다.

29

IEEE나 대학에서 진행한 연구들에서 성과가 입증된 경우들이 있다고 합니다.

30

하지만 역시 도입하기에는 장벽이 있기 때문에, SRP 원칙부터 잘 실천해 console.log()를 찍어 디버깅 하더라도 소요 시간을 줄여 보고, 비즈니스 상황에 따라 천천히 도입하는 것이 좋습니다.

# 참고 문헌

31

발표를 위해서 클린 코드, 테스트 주도 개발과 같은 책들과 컨퍼런스 영상들 그리고 현업 개발자분들의 블로그를 참고했습니다. 링크는 스터디 후에 따로 공유를 드리겠습니다.

# Outro

32

- 책 대여 가능

예제가 주로 프론트엔드 코드여서 이해가 어려우신 부분도 있었을 것 같은데요. TDD의 개념과 원칙은 다르지 않으니 그런 부분을 더 중점적으로 들으셨다면 좋겠습니다. 이상으로 마치겠습니다. 들어주셔서 감사합니다.