# 08 깊이 우선 탐색, DFS(Depth-First Search)

> https://heytech.tistory.com/55

## 1. DFS 알고리즘이란?

**DFS(Depth-First Search)**는 그래프 전체를 탐색하는 방법(i.e., 완전 탐색) 중 하나로, '깊이'를 우선적으로 탐색하는 알고리즘이다. 

**DFS**는 **한 노드를 시작으로 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색**한다. 예를 들어, DFS 알고리즘은 미로 탐색 시 한 방향으로 모든 노드를 방문하다가 더 이상 다른 노드를 방문할 수 없는 노드에 이르렀을 때, 다시 가장 가까운 갈래길로 돌아가 방문하지 않은 노드 방향으로 탐색을 이어간다.

특히 그래프에서 간선이나 변수 정보를 수시로 변경해야 하는 문제는 DFS를 활용하는 것이 효과적이다.



### 2. DFS 동작 과정

DFS 알고리즘의 동작 과정을 이해하기 위해서는 먼저 [그래프 자료구조](https://heytech.tistory.com/66)와 [스택 자료구조](https://heytech.tistory.com/46)를 먼저 이해해야 한다.



DFS 알고리즘의 구체적인 동작 과정은 다음과 같다.

1️⃣ 탐색 시작 노드 정보를 스택에 삽입하고 ***방문 처리**한다.
2️⃣ 스택 내 최상단 노드에 방문하지 않은 노드가 있다면 그 인접 노드 정보를 스택에 삽입하고 방문 처리한다.
만일 방문하지 않은 인접 노드가 없다면 스택 내 최상단 노드를 꺼낸다.
3️⃣ 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

여기서 ***방문 처리**란 탐색한 노드를 재방문하지 않도록 구분하는 것이다. 즉, 스택에 한 번이라도 삽입된 노드를 다시 삽입하지 않도록 체크하는 것이다.



이제 아래 ***그림 1*** 과 같은 그래프 예시를 통해 DFS 동작 과정을 알아보자. 노드 1을 시작 노드로 설정한다. 일반적으로 인접한 노드가 2개 이상인 경우에는 해당 노드들 중 번호가 낮은 노드부터 처리한다. 현재 **처리 중인 스택 내 최상단 노드**는 **파란색**으로,**방문 처리한 노드**는**회색**으로 표시한다.





![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img.png)



(1) 시작 노드인 노드 1을 스택에 삽입하고 방문 처리한다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826891.png)



 

(2) 스택 내 최상단 노드인 노드 1에 인접한 노드는 2, 3이 있다. 번호가 낮은 노드 2를 스택에 삽입하고 방문 처리한다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826892.png)



 

(3) 스택 내 최상단 노드인 노드 2에 인접한 노드 8을 스택에 삽입하고 방문 처리한다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826903.png)



 

(4) 스택 내 최상단 노드인 노드 8에 인접한 노드는 6과 7이 있으며, 번호가 낮은 노드 6을 스택에 삽입하고 방문 처리한다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826904.png)



 

(5) 스택 내 최상단 노드인 노드 6에 인접하며 방문하지 않은 노드 7을 스택에 삽입하고 방문 처리한다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826905.png)



 

(6) 최상단 노드인 노드 7에 인접하며 방문하지 않은 노드가 없으므로 스택에서 노드 7을 꺼낸다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826906.png)



 

(7) 최상단 노드인 노드 6에 인접하며 방문하지 않은 노드가 없으므로 스택에서 노드 6을 꺼낸다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826907.png)



 

(7) 최상단 노드인 노드 8에도 인접하며 방문하지 않은 노드가 없으므로 스택에서 노드 8을 꺼낸다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826908.png)



 

(8) 최상단 노드인 노드 2에 인접하며 방문하지 않은 노드가 없으므로 스택에서 노드 2를 꺼낸다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-16563817826909.png)



 

(9) 노드 1에 인접하면서 방문 이력이 없는 노드 3을 스택에 삽입하고 방문 처리한다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-165638178269110.png)



 

(9) 노드 3에 인접하면서 방문하지 않은 노드는 노드 4와 5가 있지만, 번호가 낮은 노드 4를 스택에 삽입하고 방문 처리한다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-165638178269111.png)



 

(10) 노드 4에 인접한 노드 5를 스택에 넣고 방문 처리한다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-165638178269112.png)



 

(11) 이제 방문하지 않은 노드가 없기 때문에 스택에서 모든 노드를 차례대로 꺼낸다.

 



![img](08%20%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89,%20DFS(Depth-First%20Search).assets/img-165638178269113.png)




결과적으로 노드의 탐색 순서, 즉 스택에 삽입한 순서는 다음과 같다.

**1 -> 2 -> 8 -> 6 -> 7 -> 3 -> 4 -> 5**



## 3. DFS 파이썬 구현

이제 앞서 살펴본 예시 그래프를 DFS 알고리즘을 통해 탐색하는 과정을 파이썬으로 구현해 본다. DFS는 스택 자료구조를 이용하는 알고리즘이므로 재귀 함수를 활용하면 간결하게 코드를 작성할 수 있다.

```python
# DFS 메서드 정의
def dfs (graph, node, visited):
    # 해당 노드를 방문 처리
    visited[node] = True
    # 탐색 순서 출력
    print(node, end = ' ')
    # 한 노드로부터 인접한 다른 노드를 재귀적으로 방문 처리
    for i in graph[node]:
        if not (visited[i]):
            dfs (graph, i, visited)
```



위와 같이 DFS 메서드를 정의해 준다.

```python
graph = [
    [],
    [2, 3],
    [1, 8],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7, 8],
    [6, 8],
    [2, 6, 7]
]
```



노드 간의 연결 정보는 위와 같이 2차원 배열을 통해 표현할 수 있다. 즉, 리스트 내 인덱스는 노드 번호를 의미하고 각 인덱스에 해당하는 원소에 해당 노드에 인접한 노드 번호가 담겨 있다.

```python
# 노드별로 방문 정보를 리스트로 표현
visited = [False] * 9
```

노드별로 방문 정보를 저장할 리스트를 초기화한다.



#### 잠깐, 왜 실제 그래프 내 노드 개수보다 2차원 배열에 원소 개수는 1개 더 많나?

리스트 내 원소의 인덱스와 노드 번호를 일치시키기 위해, 인덱스 0에 빈 리스트를 넣어줌으로써 기존 그래프 내 노드 개수보다 방문 정보를 담은 리스트 내 원소 개수를 1개 더 많게 세팅하였다. 이처럼 인덱스와 노드 번호를 일치시켜 줌으로써 보다 직관적으로 노드 간의 연결 및 방문 정보를 파악할 수 있도록 세팅하였다.

```python
# 정의한 DFS 메서드 호출(노드 1을 탐색 시작 노드로 설정)
dfs(graph, 1, visited)
```

DFS 메서드를 호출하면 탐색 순서가 차례로 출력되는 것을 확인할 수 있다.

**실행결과**

```
1 2 6 8 6 7 3 4 5
```



### 전체 소스코드

```python
# DFS 메서드 정의
def dfs (graph, node, visited):
    # 해당 노드를 방문 처리
    visited[node] = True
    # 탐색 순서 출력
    print(node, end = ' ')
    # 한 노드로부터 인접한 다른 노드를 재귀적으로 방문 처리
    for i in graph[node]:
        if not visited[i]:
            dfs(graph, i, visited)
            
graph = [
    [],
    [2, 3],
    [1, 8],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7, 8],
    [6, 8],
    [2, 6, 7]
]

# 노드별로 방문 정보를 리스트로 표현
visited = [False] * 9

# 정의한 DFS 메서드 호출(노드 1을 탐색 시작 노드로 설정)
dfs(graph, 1, visited)
```

**실행결과**

```python
1 2 6 8 6 7 3 4 5
```