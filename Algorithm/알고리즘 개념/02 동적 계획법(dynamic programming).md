# 02 동적 계획법(Dynamic Programming)

> 피보나치 수열을 재귀 함수로 구했을 때, 같은 연산을 여러 번 반복해야만 한다. 이렇게 이미 했던 연산이 반복되는 결점을 보완하기 위해서 동적 계획법이 고안되었다. 



처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 낸다는 점에서 분할 정복과 비슷하지만, 동적 계획법에서는 그 쪼개진 문제들이 중복되는 것이지만 분할 정복에서는 중복된 것이 있을 수 없다.



## 02-1 동적 계획법의 조건

1. Overlapping Subproblem(겹치는 부분 문제)
   - 겹치는 부분 문제는 어떤 문제가 여러 개의 부분 문제로 쪼개질 수 있을 때 사용하는 용어이다. 대표적인 예로 피보나치 수열이 있다. 
2. Optimal Substructure(최적 부분 구조)
   - 최적 부분 구조는 어떤 문제의 최적의 해결책이 그 부분 문제의 최적의 해결책으로부터 설계될 수 있는 경우를 말한다.



## 02-2 Memoization (Top-Down, 하향식)

동적 계획법에서 각 문제는 한 번만 풀어야 한다. 중복되는 부분 문제를 여러 번 풀지 않는다는 뜻이다. Optimal Substructure를 만족하기 때문에 같은 문제는 구할 때마다 정답이 같다. 따라서 정답을 한 번 구했으면 그 정답을 캐시에 메모해놓는다. 이렇게 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다. 이를 메모이제이션(Memoization)이라고 한다.

하향식(Top-Down) 경우 하위 문제에 대하여 정답을 계산했는지 확인해가며 문제를 자연스럽게 풀어나가는 방법이다. 이때 Memoization이 사용된다.

```python
# DP, Memoization

def fib(n):
    if n==1 or n==2:
        return 1
    else:
        return fib(n-1) + fib(n-2)

dp_Memo = [0] * 11
dp_Memo[0] = 1
dp_Memo[1] = 1

def fib_Memo(n):
    #한번도 계산한 적이 없는 경우
    if dp_Memo[n] == 0: #dp list에 계산한적이 없는경우 0으로 저장되어 있음
        dp_Memo[n] = fib(n - 1) + fib(n - 2) #재귀로 계산하여 리스트에 값 추가
    
    # 새롭게 추가 값 혹은 저장된 값 반환
    
    return dp_Memo[n]

# 피보나치 수열 항 리스트 전체 출력
for i in range(11):
    fib_Memo(i)

print(dp_Memo)

fib_Memo(10)

"""
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
output: 89
"""
```



### cf. 동적 계획법을 사용하지 않고 재귀로만 피보나치 수열을 구하는 식

```python
def fib(n):
    if n==1 or n==2:
        return 1
    else:
        return fib(n-1) + fib(n-2)


fib(10)

# 
```



## 02-3 Tabulation (Bottom-up, 상향식)

상향식(Bottom-Up)은 더 작은 하위 문제부터 살펴본 다음 작은 문제의 정답을 이용하여 큰 문제의 정답을 풀어나가는 방법이다.

```python
#DP, Tabulation(Bottom-Up, 상향식)

# 풀이 1.
def fib_Tab1(n):
    
    dp_Tab = [0] * (n + 1)
    dp_Tab[0], dp_Tab[1] = 1, 1
    
    # 작은 값(소문제)부터 직접 계산하며 진행
    
    # 2항 ~ n항 까지 피보나치 수열항 계산 (0,1 항 = 1)
    for i in range(2, n + 1):        
        dp_Tab[i] = dp_Tab[i - 1] + dp_Tab[i - 2]
    
    print(dp_Tab) # 피보나치 수열 항 리스트 전체 출력
    
    return dp_Tab[n]

fib_Tab(10)

"""
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
output: 89
"""
#DP, Tabulation(Bottom-Up, 상향식)

# 풀이 2.

def fib_Tab2(n):
	p = [1,1]
	for i in range(2, n + 1): # n번째 까지 피보나치 수열 나열
		p.append(p[-1] + p[-2]) # 마지막 2 요소의 합을 리스트에 추가
		print(p)
	return(p[-1]) #피보나치 n번째 값 Return

fib_Tab2(10)
"""
output: 89
"""
```



## 02-4 동적 계획법은 어떤 문제에 적용해야 할까

- 동적 계획법 = 소문제의 결과를 다른 소문제를 푸는데 사용하는 풀이법
- 우선 **최적성의 원리를 만족**하는지 판단해야 한다.
  - 최적성의 원리 : 부분 해가 전체 문제의 해를 구하는데 사용되는지를 의미
- 최적성의 원리가 적용되는 것이 확인 됐으면 주어진 문제를 소문제로 분해하여 최적해를 제공하는 점화식을 도출해야 한다.



## cf.

### 동적 계획법 vs 분할 정복

- 동적 계획법: 소문제 종속적
  - 피보나치 수열: 소문제가 상위 문제에 영향을 끼치며 **원소들이 종속적**이다.
- 분할 정복: 소문제 독립적
  - 퀵 정렬, 병합 정렬 : 각각 분할된 원소들이 정렬 과정에서 다른 원소들의 영향을 미치지 않는다.



### 동적 계획법 vs 그리디

- 동적 계획법: 모든 가능성 고려 → **항상 최적의 결과 도출**
- 탐욕법: '현 상태' 에서 가장 최적의 경우를 판단하여 결정 → 문제에 따라 최적해가 구해지지 않을 수 있다.



## 02-5 동적 계획법 추가 예시